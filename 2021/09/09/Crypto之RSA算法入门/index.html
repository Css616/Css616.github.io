<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    
    <title>
        Crypto之RSA算法入门 |
        
        Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="基础数学知识： 1.素数：质数，除了1和它本身外不再有其他因数。 2.合数：与质数相对，除了能被1和本身整除外，还能被其他数（0除外）整除的数。 另：1既不属于质数也 约数）（greatest common divisor）为1，即gcd(a,b)&#x3D;1，那么称a,b两数互质。 4.欧拉函数：对正整数n，欧拉函数是小于n的正整数中与n互质的数的个数记为φ(n)。欧拉函数的值叫做欧拉函数值。 5.同余">
<meta property="og:type" content="article">
<meta property="og:title" content="Crypto之RSA算法入门">
<meta property="og:url" content="http://example.com/2021/09/09/Crypto%E4%B9%8BRSA%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="基础数学知识： 1.素数：质数，除了1和它本身外不再有其他因数。 2.合数：与质数相对，除了能被1和本身整除外，还能被其他数（0除外）整除的数。 另：1既不属于质数也 约数）（greatest common divisor）为1，即gcd(a,b)&#x3D;1，那么称a,b两数互质。 4.欧拉函数：对正整数n，欧拉函数是小于n的正整数中与n互质的数的个数记为φ(n)。欧拉函数的值叫做欧拉函数值。 5.同余">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/09/09/Crypto%E4%B9%8BRSA%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/1.PNG">
<meta property="og:image" content="http://example.com/2021/09/09/Crypto%E4%B9%8BRSA%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/2.PNG">
<meta property="og:image" content="http://example.com/2021/09/09/Crypto%E4%B9%8BRSA%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/3.PNG">
<meta property="article:published_time" content="2021-09-09T13:44:18.000Z">
<meta property="article:modified_time" content="2021-10-02T13:30:03.244Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/09/09/Crypto%E4%B9%8BRSA%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/1.PNG">
    
    
    
        
            <link rel="stylesheet" href="http://example.com/css/markdown.css">
        
            <link rel="stylesheet" href="http://example.com/css/july.css">
        
    
<meta name="generator" content="Hexo 5.2.0"></head>
<body>

<div id="banner-outer" class="hidden">
    <div id="banner-image" style="background-image: url()"></div>
    <img src="https://www.gravatar.com/avatar/7a585313ed855e8d652cbb3154a6056e?s=300&amp;d=mm&amp;r=g" id="avatar">
</div>

<div id="menu-outer">
    <div id="menu-inner">
        
            <a class="false" href="http://example.com/index.html">Home</a>
        
            <a class="false" href="http://example.com/archives/index.html">Archives</a>
        
            <a class="false" href="http://example.com/about/index.html">About</a>
        
    </div>
</div>

<div id="content-outer" class="container">
    <div id="content-inner">
        <article id="post">
    <h1 id="post-title">Crypto之RSA算法入门</h1>
    <time id="post-date" datetime="2021-09-09T13:44:18.000Z">
        September 09, 2021
    </time>
    <div id="post-content" class="markdown-body">
        <p>基础数学知识：</p>
<p>1.素数：质数，除了1和它本身外不再有其他因数。</p>
<p>2.合数：与质数相对，除了能被1和本身整除外，还能被其他数（0除外）整除的数。</p>
<p>另：1既不属于质数也</p>
<p>约数）（greatest common divisor）为1，即gcd(a,b)=1，那么称a,b两数互质。</p>
<p>4.<strong>欧拉函数</strong>：对正整数n，欧拉函数是小于n的正整数中与n互质的数的个数记为φ(n)。欧拉函数的值叫做欧拉函数值。</p>
<p>5.同余定理：给正整数m及两个整数a和b，如果a-b能够被m整除，也就是说m|(a-b)，即(a-b)/m得到一个整数，则称<strong>a与b对模m同余</strong>，记作a≡b(mod m)。对模m同余是整数的一个等价关系。</p>
<p>6.<strong>模指数运算（用于求解明文）</strong>：即先进行指数运算，再进行取模运算，如：</p>
<img src="/2021/09/09/Crypto%E4%B9%8BRSA%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/1.PNG" style="zoom:50%;">

<p><strong>在Python中给出了相应的处理函数：pow（x，y，z）。</strong>函数是用于计算x的y次方，如果z存在，则再对结果进行取模，其结果等效于pow(x,y)%z</p>
<p>注：pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。</p>
<p>7.扩展欧几里得算法：</p>
<p>是欧几里得算法（又叫辗转相除法）的扩展。除了计算a、b两个整数的最大公约数，还能找到整数x、y（其中一个很可能是负数）。</p>
<p>谈到最大公因子时, 有一个事实: 给予二整数 a 与 b, 必存在有整数 x 与 y 使得ax + by = gcd(a,b)。</p>
<p>有两个数a,b，对它们进行辗转相除法，可得它们的最大公约数。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。</p>
<p>核心的算法定义即：对于不完全为0的非负整数a,b，gcd（a,b）表示a,b的最大公约数，必然存在整数对x,y使得gcd(a,b)=ax+by成立。</p>
<p>扩展欧几里得的递归实现（C语言）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) &#123;    </span><br><span class="line">        x=<span class="number">1</span>; y=<span class="number">0</span>;<span class="comment">//ax = gcd(a, 0) = a</span></span><br><span class="line">        <span class="keyword">return</span> a;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> result=exgcd(b,a%b,x,y); </span><br><span class="line">    <span class="keyword">int</span> t=x; </span><br><span class="line">    x=y; </span><br><span class="line">    y=t-a/b*y; </span><br><span class="line">    <span class="keyword">return</span> result;<span class="comment">//gcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：exgcd是用来求解不定方程、逆元等问题的工具</p>
<p>可以求解方程ax+by=gcd(a,b) 并返回gcd值</p>
<p>推导得到对应原来x, y的就是y, x-a/b*y</p>
<p>扩展欧几里得算法是之后RSA在知晓p、q、e的情况下求解d的主要思维算法。 </p>
<p>数学推导和代码还没怎么懂，参考(<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34050519/article/details/93307779">https://blog.csdn.net/weixin_34050519/article/details/93307779</a>)</p>
<p>RSA算法介绍</p>
<p>是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。</p>
<p>RSA加密解密过程涉及的元素</p>
<p>N:大整数N，模数</p>
<p>p和q：两个大质数，是N的两个因子</p>
<p>c和m：密文和明文</p>
<p>e和d：加密钥和解密钥</p>
<p>(N, e)：公钥</p>
<p>(N, d)：私钥</p>
<p>RSA公开密钥密码体制的原理</p>
<p>根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥</p>
<p>RSA算法的具体描述如下： </p>
<p>（1）任意选取两个不同的大素数p和q计算乘积</p>
<p>​                                                                    n=pq，φ(n)=（p-1）（q-1）</p>
<p>（2）任意选取一个大整数e，满足</p>
<p>​                                                                    gcd（e，φ(n)）=1</p>
<p> 整数e用做加密钥（注意：e的选取是很容易的，例如，所有大于p和q的素数都可用） ；</p>
<p>（3）确定的解密钥d，满足</p>
<p>​                                                                （de）mod φ(n)=1</p>
<p>​                                                               即de = kφ(n)+1，k&gt;=1 是一个任意的整数</p>
<p> 所以，若知道e和φ(n)，则很容易计算出d  ；</p>
<p>（4）公开整数n和e，作为公钥，秘密保存d  ；</p>
<p>（5）将明文m（m&lt;n是一个整数）加密成密文c，加密算法为 </p>
<img src="/2021/09/09/Crypto%E4%B9%8BRSA%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/2.PNG" style="zoom:80%;">

<p>（6）将密文c解密为明文m，解密算法为 </p>
<img src="/2021/09/09/Crypto%E4%B9%8BRSA%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/3.PNG" style="zoom:80%;">

<p>然而只根据n和e（注意：不是p和q）要计算出d是不可能的。</p>
<p>因此，任何人都可对明文进行加密，但只有授权用户（知道d）才可对密文解密 。</p>
<p>针对RSA的攻击方法</p>
<p>{e,n}为公开密钥，攻击者可以知道。故破解RSA最直接的方法是：分解模数n，计算n=p*q中的p与q的值，之后计算φ(n)=（p-1）（q-1）通过d×e=1mod φ(n)即可求出私钥d,之后使用{d，n}即可得出加密之前的明文。</p>

    </div>
</article>

<div id="paginator">
    
</div>

    </div>
</div>

<div id="bottom-outer">
    <div id="bottom-inner">
        2019-2022 John Doe 皖ICP备16011445号
    </div>
</div>

<div id="to-top">
    <i class="iconfont icon-up"></i>
</div>


    
        <script src="http://example.com/js/jquery-3.4.1.min.js"></script>
    
        <script src="http://example.com/js/highlight-9.13.1.min.js"></script>
    
        <script src="http://example.com/js/transition.js"></script>
    
        <script src="http://example.com/js/smooth-scroll.min.js"></script>
    



    <script>
      $(function () {
        $('#banner-outer').addClass('fade-out')
        $('#menu-outer').addClass('fade-show')

        $('pre').each(function (i, block) {
          hljs.highlightBlock(block);
        });
      })
    </script>


<script>
  $(function () {
    $(window).scroll(function () {
      if ($(window).scrollTop() > 150) {
        $("#to-top").fadeIn();
      } else {
        $("#to-top").fadeOut();
      }
    });
    $("#to-top").click(function () {
      $("body,html").animate({scrollTop: 0}, 500);
      return false;
    })
  })
</script>
</body>
</html>
